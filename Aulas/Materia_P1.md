### **1. Geoffrey Hinton e o Deep Learning (Aprendizagem Profunda)**

#### **20% Essencial para Entender 80%:**

- **O que Ã©?**  
  Deep Learning Ã© um tipo deÂ **aprendizado de mÃ¡quina**Â que usa redes neurais comÂ **mÃºltiplas camadas**Â para aprender padrÃµes complexos.

- **Por que revolucionou?**  
  Em 2006, Hinton mostrou que redes neurais profundas podiam reconhecer dÃ­gitos escritos Ã  mÃ£o comÂ **98% de precisÃ£o**, algo quase impossÃ­vel antes.

- **Analogia:**  
  Imagine uma fÃ¡brica de classificaÃ§Ã£o de cartas:
  
  - 1Âª camada: Separa letras por tamanho.
  
  - 2Âª camada: Identifica curvas e retas.
  
  - 3Âª camada: Reconhece o nÃºmero (ex: "5").  
    Quanto mais camadas, mais detalhes a rede "enxerga".

- **3 Termos-Chave:**
  
  1. **NeurÃ´nio Artificial:**Â Unidade bÃ¡sica que processa informaÃ§Ãµes (como um mini-decisor).
  
  2. **Camadas Ocultas:**Â Etapas intermediÃ¡rias onde o modelo "aprende" padrÃµes.
  
  3. **Treinamento:**Â Ajuste dos neurÃ´nios usando exemplos (dados).

---

### **2. AplicaÃ§Ãµes do Aprendizado de MÃ¡quina**

#### **20% Essencial para Entender 80%:**

- **SegmentaÃ§Ã£o de clientes:**
  
  - **O que faz?**Â Agrupa clientes com comportamentos similares (ex: quem compra livros de ficÃ§Ã£o).
  
  - **Analogia:**Â Organizar amigos em grupos no WhatsApp (esportistas, cinÃ©filos, gamers).

- **DetecÃ§Ã£o de fraudes:**
  
  - **Como funciona?**Â Identifica transaÃ§Ãµes fora do padrÃ£o (ex: compra de R$ 10.000 em outro paÃ­s).
  
  - **Exemplo:**Â Se vocÃª sÃ³ compra pÃ£es na padaria, um gasto de R$ 500 em joias aciona um alerta.

- **RecomendaÃ§Ãµes (ex: filmes):**
  
  - **Base:**Â Compara seus gostos com os de usuÃ¡rios parecidos.
  
  - **Analogia:**Â Um amigo que sempre indica sÃ©ries baseado no que vocÃª jÃ¡ assistiu.

---

### **3. O que Ã© Aprendizado de MÃ¡quina?**

#### **20% Essencial para Entender 80%:**

- **DefiniÃ§Ã£o Simplificada:**  
  AM Ã© ensinar computadores aÂ **aprender com dados**Â (ex: fotos, nÃºmeros, textos) em vez de seguir regras fixas.

- **Exemplo ClÃ¡ssico:**
  
  - **Algoritmo Tradicional:**Â Regra fixa para spam: "Se o e-mail tem a palavra 'oferta', bloqueie".
  
  - **AM:**Â O computador analisa milhares de e-mails marcados como spam eÂ **descobre sozinho**Â padrÃµes (ex: palavras como "grÃ¡tis", "urgente").

- **Analogia:**
  
  - **ProgramaÃ§Ã£o Tradicional:**Â Seguir uma receita de bolo passo a passo.
  
  - **AM:**Â Aprender a fazer bolo errando e acertando (ajustando ingredientes atÃ© ficar bom).

- **3 Termos-Chave:**
  
  1. **Dados de Treinamento:**Â Exemplos usados para ensinar o modelo (ex: e-mails marcados como spam).
  
  2. **Modelo:**Â "CÃ©rebro" do sistema que faz previsÃµes (ex: classificar spam).
  
  3. **Aprendizado:**Â Processo de ajustar o modelo para reduzir erros.

---

### **4. AM vs. InteligÃªncia Artificial (IA)**

#### **20% Essencial para Entender 80%:**

- **RelaÃ§Ã£o:**
  
  - **IA Ã© o guarda-chuva:**Â Qualquer sistema que imita inteligÃªncia humana (ex: jogar xadrez).
  
  - **AM Ã© uma parte da IA:**Â Foca em aprender com dados (ex: reconhecer rostos em fotos).

- **Analogia:**
  
  - **IA:**Â Um carro autÃ´nomo.
  
  - **AM:**Â A habilidade do carro de aprender a evitar obstÃ¡culos analisando milhares de horas de direÃ§Ã£o.

---

### **Resumo dos 20% que mais Importam:**

1. **Deep Learning**Â = Redes neurais com muitas camadas para tarefas complexas (ex: reconhecer imagens).

2. **AplicaÃ§Ãµes de AM**Â resolvem problemas reais agrupando dados, detectando anomalias ou fazendo recomendaÃ§Ãµes.

3. **AM Ã© aprender com dados**, nÃ£o seguir regras fixas.

4. **AM Ã© um subconjunto da IA**Â focado em aprendizado autÃ´nomo.

---

### **1. Por que usar Aprendizado de MÃ¡quina (AM) em vez de algoritmos tradicionais?**

#### **ComparaÃ§Ã£o Direta (20% Essencial):**

| **CritÃ©rio**     | **Algoritmos Tradicionais**                                             | **Aprendizado de MÃ¡quina**                                                       |
| ---------------- | ----------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **Regras**       | VocÃª define regrasÂ **manualmente**Â (ex: "Se X, faÃ§a Y").                | O sistemaÂ **aprende regras**Â sozinho com dados.                                  |
| **Exemplo**      | Um filtro de spam com regras fixas (ex: bloquear e-mails com "oferta"). | O filtro de spam analisa milhares de e-mails paraÂ **descobrir padrÃµes**Â de spam. |
| **Vantagem**     | PrevisÃ­vel e eficiente para problemasÂ **simples**.                      | Lida com problemasÂ **complexos**Â (ex: reconhecer rostos, prever tendÃªncias).     |
| **Quando usar?** | Tarefas estÃ¡ticas e bem definidas (ex: calcular mÃ©dia).                 | Tarefas comÂ **muitos dados**Â ou padrÃµes ocultos.                                 |

#### **Analogia:**

- **Algoritmo tradicional:**Â Seguir uma receita de bolo passo a passo.

- **AM:**Â Aprender a fazer bolo experimentando ingredientes e ajustando atÃ© acertar.

---

### **2. Passos do AM vs. Algoritmos Tradicionais (Baseado nas Imagens)**

#### **am01.png (Algoritmos Tradicionais):**

1. **Escrever regras:**Â Definir manualmente como o sistema deve funcionar.

2. **Estudar o problema:**Â Entender a lÃ³gica por trÃ¡s da tarefa.

3. **Analisar erros:**Â Corrigir falhas nas regras prÃ©-definidas.

4. **Avaliar:**Â Verificar se o resultado estÃ¡ correto.

#### **am02.png (Aprendizado de MÃ¡quina):**

1. **Treinar o algoritmo:**Â Alimentar o modelo com dados (ex: imagens de dÃ­gitos).

2. **Estudar o problema:**Â Escolher o modelo certo (ex: rede neural).

3. **Analisar erros:**Â Ajustar o modelo para reduzir falhas (ex: otimizar pesos).

4. **Avaliar:**Â Testar a precisÃ£o do modelo com novos dados.

#### **DiferenÃ§a Chave:**

- **Tradicional:**Â VocÃª programaÂ **regras explÃ­citas**.

- **AM:**Â VocÃª programa aÂ **capacidade de aprender**.

---

### **3. Conceitos de Agentes e Problemas de IA (20% Essencial)**

#### **Resumo Visual:**

Copy

[Agente]  
   â”‚  
   â–¼  
[Estado Inicial] â†’ [AÃ§Ãµes PossÃ­veis] â†’ [Modelo de TransiÃ§Ã£o]  
   â”‚  
   â–¼  
[Teste de Objetivo] â†’ [SoluÃ§Ã£o (Ã³tima ou nÃ£o)]  

#### **ExplicaÃ§Ã£o Simplificada:**

1. **Agente:**Â Um sistema que age no ambiente (ex: robÃ´ aspirador).

2. **Estado:**Â SituaÃ§Ã£o atual (ex: robÃ´ estÃ¡ na sala A).

3. **AÃ§Ãµes:**Â O que o agente pode fazer (ex: mover para a sala B).

4. **Modelo de TransiÃ§Ã£o:**Â O que acontece apÃ³s uma aÃ§Ã£o (ex: se mover para B, o estado muda).

5. **SoluÃ§Ã£o Ã“tima:**Â Caminho mais eficiente (ex: menor tempo para limpar a casa).

#### **Analogia (GPS de Carro):**

- **Estado inicial:**Â Carro em SÃ£o Paulo.

- **AÃ§Ãµes:**Â Virar Ã  esquerda, seguir em frente, etc.

- **Objetivo:**Â Chegar ao Rio de Janeiro.

- **SoluÃ§Ã£o Ã³tima:**Â Rota mais rÃ¡pida (menor custo de tempo).

---

### **4. Principais Takeaways (20% para 80% de Entendimento):**

1. **Use AM quando:**
   
   - O problema Ã© complexo (ex: reconhecer voz).
   
   - VocÃª tem muitos dados para treinar o modelo.

2. **Use algoritmos tradicionais quando:**
   
   - O problema Ã© simples e bem definido (ex: calcular juros).

3. **Agentes de IA:**
   
   - Agem em um ambiente, buscam soluÃ§Ãµes com menor custo.
   
   - A soluÃ§Ã£o Ã³tima depende do modelo de transiÃ§Ã£o e aÃ§Ãµes possÃ­veis.

---

### **Exemplo PrÃ¡tico:**

**Problema:**Â Um robÃ´ deve encontrar a saÃ­da de um labirinto.

- **Estado inicial:**Â RobÃ´ no inÃ­cio do labirinto.

- **AÃ§Ãµes:**Â Mover para frente, virar Ã  direita/esquerda.

- **Custo:**Â NÃºmero de movimentos.

- **SoluÃ§Ã£o Ã³tima:**Â Menor caminho atÃ© a saÃ­da.

**Como o AM ajudaria?**  
Treinando o robÃ´ com simulaÃ§Ãµes de labirintos para ele aprender a evitar becos sem saÃ­da! ðŸ§ 

---

### **1. Por que usar Aprendizado de MÃ¡quina (AM) em vez da forma tradicional de escrever algoritmos?**

#### **20% Essencial:**

- **ProgramaÃ§Ã£o Tradicional:**
  
  - VocÃª defineÂ **regras fixas**Â para resolver um problema (ex: "Se a temperatura > 30Â°C, ligue o ventilador").
  
  - Funciona bem para problemasÂ **simples e previsÃ­veis**.

- **Aprendizado de MÃ¡quina:**
  
  - O computadorÂ **aprende regras sozinho**Â analisando dados (ex: analisa milhares de dias de temperatura para decidir quando ligar o ventilador).
  
  - Ideal para problemasÂ **complexos ou com padrÃµes ocultos**Â (ex: reconhecer rostos em fotos).

#### **Analogia:**

- **Tradicional:**Â Seguir uma receita de bolo passo a passo.

- **AM:**Â Aprender a fazer bolo experimentando ingredientes e ajustando atÃ© acertar.

#### **Quando usar AM?**

âœ… Problemas comÂ **muitos dados**Â (ex: prever vendas).  
âœ… Tarefas que exigemÂ **adaptaÃ§Ã£o**Â (ex: detectar fraudes em tempo real).  
âŒ ProblemasÂ **simples e estÃ¡ticos**Â (ex: calcular a mÃ©dia de notas).

---

### **2. Conceitos Adicionais (Agente, Estado, AÃ§Ãµes, etc.)**

#### **20% Essencial:**

Esses conceitos sÃ£o a base para entender como umÂ **agente de IA**Â toma decisÃµes. Vamos simplificar:

| **Termo**               | **DefiniÃ§Ã£o Simplificada**                             | **Exemplo do Dia a Dia**                                   |
| ----------------------- | ------------------------------------------------------ | ---------------------------------------------------------- |
| **Agente**              | "RobÃ´" que interage com um ambiente e toma decisÃµes.   | Um carro autÃ´nomo.                                         |
| **Estado**              | SituaÃ§Ã£o atual do agente e do ambiente.                | Carro estÃ¡ a 60 km/h na rodovia.                           |
| **AÃ§Ã£o**                | Escolha que o agente pode fazer em um estado.          | Acelerar, frear, ou virar.                                 |
| **Modelo de TransiÃ§Ã£o** | PrevisÃ£o do que acontece apÃ³s uma aÃ§Ã£o.                | Se acelerar, o carro vai para 70 km/h.                     |
| **EspaÃ§o de Estados**   | Todas as situaÃ§Ãµes possÃ­veis que o agente pode estar.  | Todas as combinaÃ§Ãµes de velocidade e localizaÃ§Ã£o do carro. |
| **Objetivo**            | Meta que o agente quer alcanÃ§ar.                       | Chegar ao destino em 1 hora.                               |
| **SoluÃ§Ã£o Ã“tima**       | Melhor caminho (menor custo) para alcanÃ§ar o objetivo. | Rota mais rÃ¡pida e sem trÃ¢nsito.                           |

#### **Analogia PrÃ¡tica:**

Imagine que vocÃª Ã© umÂ **agente**Â tentando cozinhar um ovo perfeito:

- **Estado inicial:**Â Ovo cru na frigideira.

- **AÃ§Ãµes:**Â Aumentar o fogo, virar o ovo, retirar da panela.

- **Modelo de transiÃ§Ã£o:**Â Se vocÃª aumentar o fogo, o ovo queima em 2 minutos.

- **Objetivo:**Â Ovo frito com gema mole.

- **SoluÃ§Ã£o Ã³tima:**Â Fritar por 3 minutos em fogo mÃ©dio.

---

### **3. Resumindo... (Problemas para IA)**

#### **20% Essencial:**

Todo problema de IA precisa definir:

1. **Estado inicial:**Â Onde o agente comeÃ§a (ex: posiÃ§Ã£o inicial em um labirinto).

2. **AÃ§Ãµes possÃ­veis:**Â O que o agente pode fazer (ex: andar para frente, virar Ã  direita).

3. **Modelo de transiÃ§Ã£o:**Â Como o ambiente muda apÃ³s cada aÃ§Ã£o (ex: andar para frente leva Ã  prÃ³xima sala).

4. **Teste de objetivo:**Â Como saber se o problema foi resolvido (ex: saiu do labirinto).

5. **Custo da soluÃ§Ã£o:**Â Quanto "esforÃ§o" foi gasto (ex: nÃºmero de movimentos).

#### **Exemplo de AplicaÃ§Ã£o:**

**Problema:**Â Encontrar o caminho mais curto de SÃ£o Paulo ao Rio de Janeiro.

- **Estado inicial:**Â Carro em SP.

- **AÃ§Ãµes:**Â Pegar a Via Dutra, Rodovia Carvalho Pinto, etc.

- **Custo:**Â DistÃ¢ncia em quilÃ´metros.

- **SoluÃ§Ã£o Ã³tima:**Â Via Dutra (menor distÃ¢ncia).

---

### **Principais Takeaways (20% para 80% de entendimento):**

1. **AM vs. Tradicional:**
   
   - Use AM quando o problema Ã© complexo e tem muitos dados.
   
   - Use algoritmos tradicionais para tarefas simples e previsÃ­veis.

2. **Agentes e Estados:**
   
   - Um agente toma decisÃµes baseadas em seu estado atual e aÃ§Ãµes possÃ­veis.
   
   - A soluÃ§Ã£o Ã³tima Ã© o caminho de menor custo para o objetivo.

3. **Custo e SoluÃ§Ã£o:**
   
   - Toda aÃ§Ã£o tem um custo, e a IA busca minimizÃ¡-lo (ex: tempo, energia).

---

### **1. Como as mÃ¡quinas aprendem?**

#### **Analogia:**

Imagine que a mÃ¡quina Ã© umÂ **estudante**, e osÂ **dados**Â sÃ£o os livros que ela lÃª.

- **Modelos estatÃ­sticos**Â sÃ£o como o "mÃ©todo de estudo" (ex: fazer resumos, mapas mentais).

- **TÃ©cnicas de ensino**Â sÃ£o as estratÃ©gias do professor (ex: treinar com exercÃ­cios, corrigir erros).

#### **Exemplo:**

Para ensinar um modelo a reconhecer gatos em fotos:

1. **Dados:**Â Mostre milhares de fotos de gatos e nÃ£o gatos.

2. **Modelo estatÃ­stico:**Â O algoritmo identifica padrÃµes (ex: orelhas pontudas, bigodes).

3. **TÃ©cnica de ensino:**Â Ajusta os erros (ex: se confundir um cachorro com gato, o modelo "corrige" sua lÃ³gica).

---

### **2. Tipos de Aprendizado de MÃ¡quina (20% Essencial)**

#### **a) Supervisionado vs. NÃ£o Supervisionado**

| **Tipo**     | **Supervisionado**                                         | **NÃ£o Supervisionado**                                              |
| ------------ | ---------------------------------------------------------- | ------------------------------------------------------------------- |
| **Dados**    | Rotulados (ex: fotos com tags "gato" ou "nÃ£o gato").       | Sem rÃ³tulos (ex: fotos sem classificaÃ§Ã£o).                          |
| **Objetivo** | Prever rÃ³tulos (ex: classificar e-mails em spam/nÃ£o spam). | Descobrir padrÃµes ocultos (ex: agrupar clientes por comportamento). |
| **Analogia** | Aprender com um professor corrigindo suas respostas.       | Explorar um mapa desconhecido e criar seu prÃ³prio guia.             |

**Semi-Supervisionado:**

- **Exemplo:**Â 100 fotos de gatos (rotuladas) + 1.000 fotos sem rÃ³tulos.

- **Uso:**Â Quando rotular dados Ã© caro ou demorado (ex: diagnÃ³sticos mÃ©dicos).

#### **b) Batch (Lote) vs. Online (Gradativo)**

| **Tipo**        | **Batch**                                                            | **Online**                                                             |
| --------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| **Aprendizado** | De uma vez, com todos os dados.                                      | Aos poucos, com dados novos em tempo real.                             |
| **Vantagem**    | PrecisÃ£o maior (analisa tudo).                                       | AdaptaÃ§Ã£o rÃ¡pida (ex: detectar fraudes novas).                         |
| **Exemplo**     | Treinar um modelo para reconhecer rostos com um banco de dados fixo. | Atualizar recomendaÃ§Ãµes da Netflix conforme vocÃª assiste novos filmes. |

#### **c) Baseado em InstÃ¢ncia vs. Modelo**

| **Tipo**                   | **Baseado em InstÃ¢ncia**                                  | **Baseado em Modelo**                                           |
| -------------------------- | --------------------------------------------------------- | --------------------------------------------------------------- |
| **Funcionamento**          | Memoriza exemplos e compara novos casos (ex: "decoreba"). | Cria regras gerais a partir dos dados (ex: "entende a lÃ³gica"). |
| **Exemplo**                | DiagnÃ³stico mÃ©dico baseado em casos similares passados.   | Prever preÃ§os de casas usando uma fÃ³rmula matemÃ¡tica.           |
| **Medida de Similaridade** | Usa distÃ¢ncia (ex: "quÃ£o parecido Ã© com X?").             | NÃ£o usa: baseia-se em padrÃµes abstratos.                        |

---

### **3. Resumo dos 20% que mais Importam**

1. **Como aprendem?**
   
   - MÃ¡quinas aprendem como estudantes: com dados (livros), modelos (mÃ©todos) e ajustes (correÃ§Ãµes).

2. **Tipos de AM:**
   
   - **Supervisionado:**Â Rotulado (professor corrige).
   
   - **NÃ£o Supervisionado:**Â Sem rÃ³tulo (explora sozinho).
   
   - **Batch vs. Online:**Â Aprende tudo de uma vez vs. aprende continuamente.
   
   - **InstÃ¢ncia vs. Modelo:**Â Decora exemplos vs. cria regras gerais.

3. **Quando usar cada um?**
   
   - **Supervisionado:**Â Tarefas de classificaÃ§Ã£o (ex: spam).
   
   - **NÃ£o Supervisionado:**Â Descobrir grupos ou padrÃµes (ex: segmentaÃ§Ã£o de clientes).
   
   - **Online:**Â Sistemas em tempo real (ex: detecÃ§Ã£o de fraudes).

---

### **Exemplo PrÃ¡tico:**

**Problema:**Â Uma loja quer prever quais clientes vÃ£o comprar na Black Friday.

- **Supervisionado:**Â Usa dados histÃ³ricos (ex: quem comprou no passado) para prever futuros compradores.

- **NÃ£o Supervisionado:**Â Agrupa clientes em perfis (ex: "economistas", "compradores impulsivos").

- **Online:**Â Atualiza as previsÃµes diariamente com novos dados de navegaÃ§Ã£o no site.

---

### **1. Por que Python?**

#### **CaracterÃ­sticas Principais:**

- **Alto nÃ­vel:**Â Sintaxe simples, prÃ³xima da linguagem humana.

- **Interpretada:**Â ExecuÃ§Ã£o direta do cÃ³digo, sem compilaÃ§Ã£o prÃ©via.

- **Comunidade ativa:**Â Bibliotecas poderosas comoÂ **NumPy**Â (cÃ¡lculos numÃ©ricos),Â **Pandas**Â (anÃ¡lise de dados) eÂ **Matplotlib**Â (grÃ¡ficos).

#### **Exemplo de Uso:**

python

#InstalaÃ§Ã£o das bibliotecas (comando no terminal):

#pip install numpy pandas matplotlib

---

### **2. Tipos de Dados em Python**

#### **a) NÃºmeros:**

| **Tipo** | **Exemplo**     | **DescriÃ§Ã£o**                       |
| -------- | --------------- | ----------------------------------- |
| `int`    | `5`,Â `-10`      | NÃºmeros inteiros.                   |
| `float`  | `3.14`,Â `-0.5`  | NÃºmeros decimais.                   |
| `bool`   | `True`,Â `False` | Valores lÃ³gicos (verdadeiro/falso). |

#### **b) SequÃªncias:**

| **Tipo** | **MutÃ¡vel?** | **Exemplo**                      | **DescriÃ§Ã£o**                   |
| -------- | ------------ | -------------------------------- | ------------------------------- |
| `str`    | NÃ£o          | `"Python"`                       | Textos.                         |
| `list`   | Sim          | `[1, "a", True]`                 | ColeÃ§Ã£o ordenada e modificÃ¡vel. |
| `tuple`  | NÃ£o          | `(1, 2, 3)`                      | ColeÃ§Ã£o ordenada e imutÃ¡vel.    |
| `dict`   | Sim          | `{"nome": "Pablo", "idade": 30}` | Pares chave-valor.              |

---

### **3. Trabalhando com Strings**

#### **a) Slicing (Fatiamento):**

**strMinhaString = 'Pablo Ã© professor de ADS'**

print(strMinhaString[0])       # SaÃ­da: 'P' (primeiro caractere)  
print(strMinhaString[1:5])     # SaÃ­da: 'ablo' (Ã­ndices 1 a 4)  
print(strMinhaString[5:])      # SaÃ­da: ' Ã© professor de ADS' (do Ã­ndice 5 atÃ© o fim)  
print(strMinhaString[:5])      # SaÃ­da: 'Pablo' (do inÃ­cio atÃ© o Ã­ndice 4)  
print(strMinhaString[-6])      # SaÃ­da: 'd' (6Âº caractere a partir do fim)  
print(strMinhaString[::2])     # SaÃ­da: 'PboÃ©poesrd D' (pula de 2 em 2 caracteres)  

#**Exemplo com nÃºmeros:**

numeros = '123456789'  
print(numeros[1:7:2])          # SaÃ­da: '246' (Ã­ndices 1, 3, 5)  
print(numeros[::-1])           # SaÃ­da: '987654321' (inverte a string)  

#### **b) ConcatenaÃ§Ã£o e MultiplicaÃ§Ã£o:**

nome = 'Pablo'  
nome += ' Ã© professor'  
print(nome)                    # SaÃ­da: 'Pablo Ã© professor'  

print('z' * 10)               # SaÃ­da: 'zzzzzzzzzz'  
print('2' + '3')              # SaÃ­da: '23' (concatenaÃ§Ã£o)  
print(2 + 3)                  # SaÃ­da: 5 (soma numÃ©rica) 

#### **c) MÃ©todos Ãšteis:**

**texto = 'Pablo Ã© professor de ADS'**  

print(texto.upper())           # SaÃ­da: 'PABLO Ã‰ PROFESSOR DE ADS'  
print(texto.lower())           # SaÃ­da: 'pablo Ã© professor de ads'  

**#Substituir parte da string:**

novo_texto = texto.replace('Pablo', 'Carlos')  
print(novo_texto)              # SaÃ­da: 'Carlos Ã© professor de ADS'

#### **d) Imutabilidade das Strings:**

texto = 'Casa'  

#texto[0] = 'c' â†’ ERRO! (strings sÃ£o imutÃ¡veis)

**#SoluÃ§Ã£o: Criar uma nova string**

novo_texto = 'c' + texto[1:]  
print(novo_texto)              # SaÃ­da: 'casa'  

---

### **4. Aspas e Strings Multilinha**

#### **a) Aspas Simples vs. Duplas:**

print("Hello 'World'!")        # SaÃ­da: Hello 'World'!  
print('Hello "World"!')        # SaÃ­da: Hello "World"! 

**#Usando escape:**

print('Hello \'World\'!')      # SaÃ­da: Hello 'World'! 

#### **b) Strings Multilinha:**

texto = '''Este Ã© um exemplo  
de string em mÃºltiplas  
linhas.'''  

print(texto)  

#SaÃ­da:
Este Ã© um exemplo
de string em mÃºltiplas
linhas.

---

### **5. OperaÃ§Ãµes com Listas e Tuplas**

#### **a) Listas (MutÃ¡veis):**

**lista = [1, "Python", True]**  
lista[0] = 10                 # AlteraÃ§Ã£o permitida  
print(lista)                  # SaÃ­da: [10, 'Python', True]

#### **b) Tuplas (ImutÃ¡veis):**

tupla = (1, "Python", True)
#tupla[0] = 10 â†’ ERRO! (nÃ£o pode ser alterada)

---

### **6. Principais Bibliotecas**

#### **a) NumPy (Arrays NumÃ©ricos):**

import numpy as np  
array = np.array([1, 2, 3])  
print(array * 2)

# SaÃ­da: [2 4 6]

#### **b) Pandas (AnÃ¡lise de Dados):**

import pandas as pd  
dados = {'Nome': ['Ana', 'JoÃ£o'], 'Idade': [25, 30]}  
tabela = pd.DataFrame(dados)  
print(tabela)  

#SaÃ­da:

   Nome  Idade
0  Ana     25
1 JoÃ£o     30

#### **c) Matplotlib (GrÃ¡ficos):**

import matplotlib.pyplot as plt  
plt.plot([1, 2, 3], [4, 5, 1])  
plt.xlabel('Eixo X')  
plt.ylabel('Eixo Y')  
plt.show()  

---

### **7. Resumo dos 20% Essenciais**

1. **Strings:**
   
   - UseÂ `[start:stop:step]`Â para fatiar.
   
   - MÃ©todos comoÂ `upper()`,Â `lower()`, eÂ `replace()`Â sÃ£o essenciais.
   
   - Strings sÃ£o imutÃ¡veis: sempre crie novas strings para modificaÃ§Ãµes.

2. **Listas vs. Tuplas:**
   
   - Listas sÃ£o flexÃ­veis (`lista = [1, 2, 3]`).
   
   - Tuplas sÃ£o imutÃ¡veis (`tupla = (1, 2, 3)`).

3. **Bibliotecas:**
   
   - **Pandas**Â para dados tabulares.
   
   - **NumPy**Â para cÃ¡lculos numÃ©ricos.
   
   - **Matplotlib**Â para visualizaÃ§Ã£o.

---

### **1. Trabalhando com Strings: Split e Fatiamento**

#### **a) Dividindo Strings em Listas (`split()`):**

**#Exemplo 1: Split por espaÃ§os**

strMinhaString = 'Pablo Ã© professor de ADS'  
lista_palavras = strMinhaString.split()  
print(lista_palavras)  

**#SaÃ­da: ['Pablo', 'Ã©', 'professor', 'de', 'ADS']**

**#Exemplo 2: Split por vÃ­rgulas**

pizzas = 'calabreza, portuguesa, marguerita, frango catupiri, bacon com frango, pepperoni'  
lista_pizzas = pizzas.split(', ')  
print(lista_pizzas)  

**#SaÃ­da: ['calabreza', 'portuguesa', 'marguerita', 'frango catupiri', 'bacon com frango', 'pepperoni']**

**ObservaÃ§Ã£o:**

- `split()`Â sem argumentos divide por espaÃ§os.

- `split(', ')`Â divide por vÃ­rgula seguida de espaÃ§o.

---

### **2. FormataÃ§Ã£o de Strings (f-strings e %)**

#### **f-strings (Moderno e Recomendado):**

nome = 'Pablo'  
print(f'Meu nome Ã©: {nome}.')  

**#SaÃ­da: Meu nome Ã©: Pablo.**

#### **Caracteres Especiais e ParÃ¢metros:**

| **ParÃ¢metro** | **Uso**                              | **Exemplo**                                        |
| ------------- | ------------------------------------ | -------------------------------------------------- |
| `%s`          | Substitui por string.                | `print('Nome: %s' % 'Ana')`                        |
| `%r`          | RepresentaÃ§Ã£o "crua" (inclui aspas). | `print('Texto: %r' % 'OlÃ¡')`Â â†’Â `'OlÃ¡'`             |
| `\t`          | TabulaÃ§Ã£o (espaÃ§o de tab).           | `print('Nome:\tAna')`                              |
| `%x.yf`       | Formata nÃºmeros decimais.            | `%5.2f`Â â†’ 2 casas decimais, 5 caracteres no total. |

---

### **3. Tuplas (ImutÃ¡veis) vs. Listas (MutÃ¡veis)**

#### **a) Criando e Usando Tuplas:**

**#Tupla de sabores de pizza**

tupla_pizzas = ('calabresa', 'marguerita', 'portuguesa')

#Tentar modificar â†’ ERRO!
#tupla_pizzas[0] = 'frango'  # NÃ£o permitido!

**#MÃ©todos de Tuplas:**

print(tupla_pizzas.count('calabresa')) 
// SaÃ­da: 1 (quantas vezes aparece)  
print(tupla_pizzas.index('marguerita')) 
// SaÃ­da: 1 (Ã­ndice do elemento)

#### **b) Listas (Para ComparaÃ§Ã£o):**

lista_pizzas = ['calabresa', 'marguerita', 'portuguesa']  
lista_pizzas[0] = 'frango'  // ModificaÃ§Ã£o permitida!  
print(lista_pizzas)  
// SaÃ­da: ['frango', 'marguerita', 'portuguesa']

**DiferenÃ§a Chave:**

- **Tuplas**Â sÃ£o imutÃ¡veis (usadas para dados fixos, como coordenadas).

- **Listas**Â sÃ£o mutÃ¡veis (usadas para coleÃ§Ãµes dinÃ¢micas).

---

### **4. Principais Takeaways**

1. **`split()`:**
   
   - Transforma strings em listas.
   
   - UseÂ `split(', ')`Â para separar por vÃ­rgulas e espaÃ§os.

2. **FormataÃ§Ã£o de Strings:**
   
   - PrefiraÂ **f-strings**Â (ex:Â `f'Nome: {nome}'`).
   
   - UseÂ `%`Â apenas para compatibilidade com cÃ³digo antigo.

3. **Tuplas vs. Listas:**
   
   - **Tuplas:**Â ImutÃ¡veis, usadas para dados fixos.
   
   - **Listas:**Â MutÃ¡veis, usadas para dados que mudam.

4. **MÃ©todos de Tuplas:**
   
   - `count()`: Conta ocorrÃªncias de um elemento.
   
   - `index()`: Retorna o Ã­ndice de um elemento.

---

### **Exemplo Integrado (Juntando Tudo):**

**Dividindo uma string em lista**

clientes = 'Ana, JoÃ£o, Maria, Pedro'  
lista_clientes = clientes.split(', ')  

**Formatando com f-strings**

for cliente in lista_clientes:  
    print(f'Cliente: {cliente.upper()}')  

**SaÃ­da:**

Cliente: ANA

Cliente: JOÃƒO

Cliente: MARIA

Cliente: PEDRO

---

# **ExercÃ­cios**

### **ExercÃ­cio 1: Primeiro Nome via Slice e Split**

**Objetivo:**Â Extrair o primeiro nome de uma string usando duas tÃ©cnicas diferentes.

#### **SoluÃ§Ã£o:**

Passo A: Carregar o nome completo

**strMeuNome = "Pablo Coelho de Souza"  **

Passo B1: Usando SLICE (fatiamento)
Encontra o Ã­ndice do primeiro espaÃ§o e fatia atÃ© lÃ¡

`espaco_index = strMeuNome.index(' ')  
primeiro_nome_slice = strMeuNome[:espaco_index]  
print("Via SLICE:", primeiro_nome_slice)  `

Passo B2: Usando SPLIT
Divide a string em uma lista e pega o primeiro elemento

`primeiro_nome_split = strMeuNome.split()[0]  
print("Via SPLIT:", primeiro_nome_split)`  

**ExplicaÃ§Ã£o:**

- **Slice:**Â UsamosÂ `index(' ')`Â para encontrar onde o primeiro espaÃ§o estÃ¡ e fatiar atÃ© esse ponto.

- **Split:**Â Dividimos a string em uma lista de palavras (`['Pablo', 'Coelho', 'de', 'Souza']`) e selecionamos o primeiro item (`[0]`).

**SaÃ­da:**

Via SLICE: Pablo  
Via SPLIT: Pablo  

---

### **ExercÃ­cio 2: Testando FormataÃ§Ã£o de Strings**

**Objetivo:**Â Entender os comportamentos deÂ `%s`,Â `%r`,Â `%d`, eÂ `%f`.

#### **SoluÃ§Ã£o:**

python

Copy

print('O nome Ã© %s.' % 'Pablo')           # SaÃ­da: O nome Ã© Pablo.  
print('O nome Ã© %r.' % 'Pablo')           # SaÃ­da: O nome Ã© 'Pablo'. (com aspas)  
print('O nome Ã© %s.' % 'Pablo \t Coelho') # SaÃ­da: O nome Ã© Pablo   Coelho. (com tabulaÃ§Ã£o)  
print('O nome Ã© %r.' % 'Pablo \t Coelho') # SaÃ­da: O nome Ã© 'Pablo \t Coelho'. (mostra o \t)  

print('O Pablo tem R$ %s na carteira.' % 3.75)  # SaÃ­da: O Pablo tem R$ 3.75 na carteira.  
print('O Pablo tem R$ %d na carteira.' % 3.75)  # SaÃ­da: O Pablo tem R$ 3 na carteira. (%d trunca para inteiro)  

print('Ponto flutuante: %5.2f' % 13.144)  # SaÃ­da: Ponto flutuante: 13.14 (5 caracteres, 2 decimais)  
print('Ponto flutuante: %1.0f' % 13.144)  # SaÃ­da: Ponto flutuante: 13 (1 caractere, 0 decimais)  
print('Ponto flutuante: %1.5f' % 13.144)  # SaÃ­da: Ponto flutuante: 13.14400 (5 decimais)  
print('Ponto flutuante: %10.2f' % 13.144) # SaÃ­da: Ponto flutuante:      13.14 (10 caracteres)  
print('Ponto flutuante: %25.2f' % 13.144) # SaÃ­da: Ponto flutuante:                   13.14 (25 caracteres)  

**ExplicaÃ§Ã£o:**

- **`%s`:**Â Exibe o valor como string, ignorando caracteres especiais (comoÂ `\t`).

- **`%r`:**Â Mostra a representaÃ§Ã£o "crua" (raw), incluindo aspas e caracteres especiais.

- **`%d`:**Â Converte o valor para inteiro (trunca decimais).

- **`%x.yf`:**
  
  - `x`: NÃºmero total de caracteres (incluindo o ponto).
  
  - `y`: NÃºmero de casas decimais.
  
  - Exemplo:Â `%10.2f`Â alinha o nÃºmero em 10 caracteres com 2 casas decimais.

---

### **ExercÃ­cio 3: Tuple com Letras Repetidas**

**Objetivo:**Â Criar uma tuple com as primeiras letras do alfabeto, repetindo 'a' trÃªs vezes.

**Objetivo:**Â Entender os comportamentos deÂ `%s`,Â `%r`,Â `%d`, eÂ `%f`.

#### **SoluÃ§Ã£o:**

python

Copy

print('O nome Ã© %s.' % 'Pablo')           # SaÃ­da: O nome Ã© Pablo.  
print('O nome Ã© %r.' % 'Pablo')           # SaÃ­da: O nome Ã© 'Pablo'. (com aspas)  
print('O nome Ã© %s.' % 'Pablo \t Coelho') # SaÃ­da: O nome Ã© Pablo   Coelho. (com tabulaÃ§Ã£o)  
print('O nome Ã© %r.' % 'Pablo \t Coelho') # SaÃ­da: O nome Ã© 'Pablo \t Coelho'. (mostra o \t)  

print('O Pablo tem R$ %s na carteira.' % 3.75)  # SaÃ­da: O Pablo tem R$ 3.75 na carteira.  
print('O Pablo tem R$ %d na carteira.' % 3.75)  # SaÃ­da: O Pablo tem R$ 3 na carteira. (%d trunca para inteiro)  

print('Ponto flutuante: %5.2f' % 13.144)  # SaÃ­da: Ponto flutuante: 13.14 (5 caracteres, 2 decimais)  
print('Ponto flutuante: %1.0f' % 13.144)  # SaÃ­da: Ponto flutuante: 13 (1 caractere, 0 decimais)  
print('Ponto flutuante: %1.5f' % 13.144)  # SaÃ­da: Ponto flutuante: 13.14400 (5 decimais)  
print('Ponto flutuante: %10.2f' % 13.144) # SaÃ­da: Ponto flutuante:      13.14 (10 caracteres)  
print('Ponto flutuante: %25.2f' % 13.144) # SaÃ­da: Ponto flutuante:                   13.14 (25 caracteres)  

**ExplicaÃ§Ã£o:**

- **`%s`:**Â Exibe o valor como string, ignorando caracteres especiais (comoÂ `\t`).

- **`%r`:**Â Mostra a representaÃ§Ã£o "crua" (raw), incluindo aspas e caracteres especiais.

- **`%d`:**Â Converte o valor para inteiro (trunca decimais).

- **`%x.yf`:**
  
  - `x`: NÃºmero total de caracteres (incluindo o ponto).
  
  - `y`: NÃºmero de casas decimais.
  
  - Exemplo:Â `%10.2f`Â alinha o nÃºmero em 10 caracteres com 2 casas decimais.

---

### **ExercÃ­cio 3: Tuple com Letras Repetidas**

**Objetivo:**Â Criar uma tuple com as primeiras letras do alfabeto, repetindo 'a' trÃªs vezes.

#### **SoluÃ§Ã£o:**

**Objetivo:**Â Entender os comportamentos deÂ `%s`,Â `%r`,Â `%d`, eÂ `%f`.

#### 

#### **SoluÃ§Ã£o:**

print('O nome Ã© %s.' % 'Pablo')           # SaÃ­da: O nome Ã© Pablo.  
print('O nome Ã© %r.' % 'Pablo')           # SaÃ­da: O nome Ã© 'Pablo'. (com aspas)  
print('O nome Ã© %s.' % 'Pablo \t Coelho') 

# SaÃ­da: O nome Ã© Pablo   Coelho. (com tabulaÃ§Ã£o)

print('O nome Ã© %r.' % 'Pablo \t Coelho') 

# SaÃ­da: O nome Ã© 'Pablo \t Coelho'. (mostra o \t)

print('O Pablo tem RS %s na carteira.' % 3.75) 
#SaÃ­da: O Pablo tem RS 3.75 na carteira.  

print('O Pablo tem RS %d na carteira.' % 3.75)
#SaÃ­da: O Pablo tem R$ 3 na carteira. (%d trunca para inteiro)  

print('Ponto flutuante: %5.2f' % 13.144)
#SaÃ­da: Ponto flutuante: 13.14 (5 caracteres, 2 decimais)  

print('Ponto flutuante: %1.0f' % 13.144)  
#SaÃ­da: Ponto flutuante: 13 (1 caractere, 0 decimais)  

print('Ponto flutuante: %1.5f' % 13.144)  
#SaÃ­da: Ponto flutuante: 13.14400 (5 decimais)  

print('Ponto flutuante: %10.2f' % 13.144)
#SaÃ­da: Ponto flutuante:      13.14 (10 caracteres)  

print('Ponto flutuante: %25.2f' % 13.144) 
#SaÃ­da: Ponto flutuante:                   13.14 (25 caracteres) 

**ExplicaÃ§Ã£o:**

- **`%s`:**Â Exibe o valor como string, ignorando caracteres especiais (comoÂ `\t`).

- **`%r`:**Â Mostra a representaÃ§Ã£o "crua" (raw), incluindo aspas e caracteres especiais.

- **`%d`:**Â Converte o valor para inteiro (trunca decimais).

- **`%x.yf`:**
  
  - `x`: NÃºmero total de caracteres (incluindo o ponto).
  
  - `y`: NÃºmero de casas decimais.
  
  - Exemplo:Â `%10.2f`Â alinha o nÃºmero em 10 caracteres com 2 casas decimais.

---

### **ExercÃ­cio 3: Tuple com Letras Repetidas**

**Objetivo:**Â Criar uma tuple com as primeiras letras do alfabeto, repetindo 'a' trÃªs vezes.

#### **SoluÃ§Ã£o:**

Criando a tuple
alfabeto = ('a', 'a', 'a', 'b', 'c', 'd', 'e')  

**Imprimindo resultados**

print("Tamanho da Tuple:", len(alfabeto))        # SaÃ­da: 7  
print("Quantidade de 'a's:", alfabeto.count('a')) # SaÃ­da: 3  
print("PosiÃ§Ã£o de 'c':", alfabeto.index('c'))    # SaÃ­da: 4 

**ExplicaÃ§Ã£o:**

- A tuple inclui 3 letras 'a' seguidas por 'b', 'c', 'd', 'e'.

- `len()`Â retorna o nÃºmero total de elementos.

- `count('a')`Â conta quantas vezes 'a' aparece.

- `index('c')`Â retorna a posiÃ§Ã£o da primeira ocorrÃªncia de 'c' (Ã­ndice 4).

---

### **ExercÃ­cio 4: AnÃ¡lise de Tuple Existente**

**Objetivo:**Â Entender mÃ©todos bÃ¡sicos de tuples.

#### **SoluÃ§Ã£o:**

myTuple = ('a', 'a', 'a', 'b', 'c', 'd', 'e')  

print(len(myTuple))       # SaÃ­da: 7 (tamanho da tuple)  
print(myTuple.count('a')) # SaÃ­da: 3 (quantidade de 'a's)  
print(myTuple.index('c')) # SaÃ­da: 4 (posiÃ§Ã£o de 'c')

**ExplicaÃ§Ã£o:**

- **`len()`:**Â Conta todos os elementos da tuple.

- **`count('a')`:**Â Conta ocorrÃªncias do elemento 'a'.

- **`index('c')`:**Â Retorna o Ã­ndice da primeira ocorrÃªncia de 'c'.

---

### **Resumo Final**

1. **Slice vs. Split:**
   
   - UseÂ `slice`Â quando souber a posiÃ§Ã£o exata do corte.
   
   - UseÂ `split`Â para dividir a string em partes baseadas em um separador.

2. **FormataÃ§Ã£o comÂ `%`:**
   
   - `%s`Â para strings,Â `%r`Â para representaÃ§Ã£o crua,Â `%d`Â para inteiros,Â `%f`Â para decimais.

3. **Tuples:**
   
   - ImutÃ¡veis e eficientes para dados fixos.
   
   - MÃ©todos Ãºteis:Â `count()`,Â `index()`,Â `len()`.

---

### **1. Sets (Conjuntos)**

#### **O que sÃ£o?**

ColeÃ§ÃµesÂ **nÃ£o ordenadas**Â de elementosÂ **Ãºnicos**.

- **Uso principal:**Â Remover duplicatas e verificar pertencimento de forma eficiente.

- **CaracterÃ­sticas:**
  
  - **MutÃ¡veis:**Â VocÃª pode adicionar/remover elementos.
  
  - **NÃ£o indexados:**Â NÃ£o Ã© possÃ­vel acessar elementos por Ã­ndice.

#### **Exemplos PrÃ¡ticos:**

**Criando um set**
frutas = {"maÃ§Ã£", "banana", "laranja"}  
frutas.add("uva")  # Adiciona "uva"  
print(frutas)
SaÃ­da: {'maÃ§Ã£', 'banana', 'laranja', 'uva'} (ordem aleatÃ³ria)

**Removendo duplicatas de uma lista**
lista_repetida = [1, 2, 2, 3, 3, 3]  
sem_duplicatas = set(lista_repetida)  
print(sem_duplicatas)
SaÃ­da: {1, 2, 3}

#### **CaracterÃ­sticas:**

- ColeÃ§ÃµesÂ **nÃ£o ordenadas**Â de elementosÂ **Ãºnicos**.

- Ãšteis para remover duplicatas e verificar pertencimento.

#### **Exemplo 1: Criando um Set**

setMeuConjunto = set()  
setMeuConjunto.add('a')  
setMeuConjunto.add('d')  
setMeuConjunto.add('b')  
setMeuConjunto.add(2)  
print(setMeuConjunto)  # SaÃ­da: {'d', 'b', 2, 'a'} (ordem aleatÃ³ria)

#### **Exemplo 2: Removendo Duplicatas**

lista_repetida = [1,1,1,2,2,21,3,4,51,23,1,2,3,5,8]  
set_sem_duplicatas = set(lista_repetida)  
print(set_sem_duplicatas)  # SaÃ­da: {1, 2, 3, 4, 5, 8, 51, 21, 23}  

---

### **2. Trabalhando com Arquivos**

#### **Etapas BÃ¡sicas:**

1. **Abrir o arquivo:**Â Especificar o modo de abertura (`r`Â para leitura,Â `w`Â para escrita,Â `a`Â para append).

2. **Manipular o conteÃºdo:**Â Ler ou escrever dados.

3. **Fechar o arquivo:**Â Liberar recursos do sistema.

### **O que Ã© o modoÂ `'a'`Â (append)?**

O modoÂ **`'a'`**Â (abreviaÃ§Ã£o deÂ **append**, que significa "acrescentar" em inglÃªs) Ã© usado paraÂ **adicionar conteÃºdo ao final de um arquivo existente**, sem apagar o que jÃ¡ estÃ¡ escrito.

#### **CaracterÃ­sticas principais:**

1. **NÃ£o sobrescreve o arquivo:**
   
   - Se o arquivo jÃ¡ existir, o conteÃºdo novo Ã© adicionadoÂ **apÃ³s o Ãºltimo caractere**Â do arquivo.
   
   - Se o arquivo nÃ£o existir, ele serÃ¡Â **criado automaticamente**.

2. **Uso tÃ­pico:**
   
   - Adicionar logs, atualizar registros ou escrever dados novos sem perder o histÃ³rico.

### **ComparaÃ§Ã£o com outros modos de abertura:**

| **Modo** | **Nome**             | **Funcionalidade**                                                      |
| -------- | -------------------- | ----------------------------------------------------------------------- |
| `'r'`    | Read (leitura)       | Abre o arquivo apenas para leitura.                                     |
| `'w'`    | Write (escrita)      | Abre o arquivo para escrita,Â **apagando o conteÃºdo anterior**.          |
| `'a'`    | Append (acrescentar) | Adiciona conteÃºdo ao final do arquivo (**sem apagar o que jÃ¡ existe**). |

### **Exemplo PrÃ¡tico:**

#### **Escrevendo em um arquivo com `'a':**

**Abre o arquivo em modo append (ou cria se nÃ£o existir)**

with open("dados.txt", "a", encoding="utf-8") as arquivo:  
    arquivo.write("Nova linha de texto.\n")  # \n para pular linha

#### **Resultado:**

- Se o arquivoÂ `dados.txt`Â jÃ¡ tivesse:
  Linha 1.  
  Linha 2.  

- ApÃ³s executar o cÃ³digo, ficaria:
  Linha 1.  
  Linha 2.  
  Nova linha de texto.

### **ObservaÃ§Ãµes Importantes:**

1. **Quebras de linha (`\n`):**
   
   - Se vocÃª nÃ£o incluirÂ `\n`, o conteÃºdo serÃ¡ adicionado naÂ **mesma linha**Â do Ãºltimo caractere.

2. **Modos combinados:**
   
   - Existe tambÃ©m o modoÂ `'a+'`, que permiteÂ **ler e escrever**Â no arquivo (Ãºtil para atualizaÃ§Ãµes mais complexas).

3. **SeguranÃ§a:**
   
   - UseÂ `with open(...) as`Â para garantir que o arquivo sejaÂ **fechado automaticamente**, mesmo se ocorrer um erro.

### **Quando usarÂ `'a'`?**

- Quando vocÃª precisaÂ **preservar o conteÃºdo original**Â do arquivo e apenas adicionar novos dados.

- Exemplos: registro de atividades, histÃ³rico de transaÃ§Ãµes, logs de sistemas.

### **Exemplo Seguro (usandoÂ `with`):**

**Escrevendo em um arquivo**
with open("dados.txt", "w") as arquivo:  
    arquivo.write("OlÃ¡, mundo!\n")

**Lendo um arquivo**

with open("dados.txt", "r") as arquivo:  
    conteudo = arquivo.read()  
    print(conteudo)  # SaÃ­da: "OlÃ¡, mundo!"

#### **a) Criar e Escrever:**

**#Passo 1: Criar arquivo (modo 'x')**

f = open("meuArquivo.txt", "x")  
f.close()  

**#Passo 2: Escrever (modo 'a' para append)**

f = open("meuArquivo.txt", "a")  
f.write("Minha primeira linha.")  
f.write("Minha segunda linha.\nTerceira linha")  # \n pula linha  
f.close()  

#### **b) Ler Arquivo:**

f = open("meuArquivo.txt", "r")  
conteudo = f.read()  
print(conteudo)  
f.close()

**SaÃ­da:**

Minha primeira linha.Minha segunda linha.

Terceira linha

**ObservaÃ§Ã£o:**Â A primeira linha nÃ£o pulou porque faltouÂ `\n`Â apÃ³s a primeira escrita.

---

### **3. Operadores de ComparaÃ§Ã£o**

#### **Tabela de Operadores:**

| **Operador** | **DescriÃ§Ã£o**  | **Exemplo**       |
| ------------ | -------------- | ----------------- |
| `==`         | Igualdade      | `3 == 3`Â â†’Â `True` |
| `!=`         | Diferente      | `3 != 4`Â â†’Â `True` |
| `>`          | Maior que      | `3 > 4`Â â†’Â `False` |
| `<`          | Menor que      | `3 < 4`Â â†’Â `True`  |
| `>=`         | Maior ou igual | `3 >= 3`Â â†’Â `True` |
| `<=`         | Menor ou igual | `3 <= 4`Â â†’Â `True` |

#### **Exemplo com Cadeias (AND/OR):**

a, b, c = 1, 2, 3  
print(a == b or a == a)          # True (OR: uma condiÃ§Ã£o verdadeira)  
print(a == b and a == a)         # False (AND: ambas precisam ser verdadeiras)  

---

### **4. Estruturas de DecisÃ£o (if/elif/else)**

#### **Funcionamento:**

- **`if`:**Â Verifica uma condiÃ§Ã£o. Se verdadeira, executa o bloco associado.

- **`elif`:**Â Verifica condiÃ§Ãµes adicionais se a anterior for falsa.

- **`else`:**Â Executa um bloco se todas as condiÃ§Ãµes anteriores forem falsas.

#### **Exemplo BÃ¡sico:**

idade = 18  

if idade < 12:  
    print("CrianÃ§a")  
elif 12 <= idade < 18:  
    print("Adolescente")  
else:  
    print("Adulto")  

---

### **5. Estruturas de RepetiÃ§Ã£o (FOR)**

#### **Uso:**Â Iterar sobre elementos de uma sequÃªncia (listas, strings, etc.).

#### **Exemplos:**

**Loop em uma lista**
numeros = [1, 2, 3]  
for num in numeros:  
    print(num * 2)  # SaÃ­da: 2, 4, 6

**Loop com range**

for i in range(0, 10, 2):  
    print(i)  # SaÃ­da: 0, 2, 4, 6, 8  

**Loop com enumerate (Ã­ndice e valor)**

for indice, valor in enumerate(["a", "b", "c"]):  
    print(f"Ãndice: {indice}, Valor: {valor}")

#### **a) Loop com Range:**

for i in range(0, 10, 2):  # InÃ­cio: 0, Fim: 10, Passo: 2  
    print(i)  

**SaÃ­da: 0, 2, 4, 6, 8**

#### **b) Loop em Listas:**

lista = [1, 2, 3, 4, 5]  
for numero in lista:  
      print(numero)  # Imprime cada nÃºmero da lista  

#### **c) Verificar Par/Ãmpar:**

for num in range(1, 11):  
    if num % 2 == 0:  
        print(f"{num} Ã© par")  
    else:  
        print(f"{num} Ã© Ã­mpar")  

---

### **6. FunÃ§Ã£o ZIP**

#### **PropÃ³sito:**

Combinar elementos de mÃºltiplas sequÃªncias em pares/tuplas.

#### **Exemplo:**

#### **Combinando Listas:**

nomes = ['Ana', 'JoÃ£o', 'Maria']  
idades = [25, 30, 28]  

for nome, idade in zip(nomes, idades):  
    print(f"{nome} tem {idade} anos")  

**SaÃ­da:**
Ana tem 25 anos
JoÃ£o tem 30 anos
Maria tem 28 anos

---

### **7. OperaÃ§Ãµes com Listas**

#### **OperaÃ§Ãµes Comuns:**

- **Adicionar elementos:**Â `append()`,Â `insert()`,Â `extend()`.

- **Remover elementos:**Â `remove()`,Â `pop()`,Â `clear()`.

- **OrdenaÃ§Ã£o:**Â `sort()`,Â `sorted()`.

- **Busca:**Â `index()`,Â `count()`.

#### **Exemplos:**

**Criando uma lista**
lista = [1, 2, 3]  
lista.append(4)  # [1, 2, 3, 4]  
lista.sort(reverse=True)  # [4, 3, 2, 1]

**List comprehension (criaÃ§Ã£o concisa)**
quadrados = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]

#### **a) Verificar ExistÃªncia (IN):**

lista = [1, 2, 3]  
print(1 in lista)  # SaÃ­da: True  

#### **b) Maior e Menor Elemento:**

lista = [5, 3, 8, 1]  
print(max(lista))  # SaÃ­da: 8  
print(min(lista))  # SaÃ­da: 1  

---

### **8. Gerando NÃºmeros AleatÃ³rios**

#### **MÃ³duloÂ `random`:**

- **`randint(a, b)`:**Â Gera um inteiro aleatÃ³rio entreÂ `a`Â eÂ `b`.

- **`random()`:**Â Gera um float aleatÃ³rio entre 0 e 1.

- **`choice(sequencia)`:**Â Escolhe um elemento aleatÃ³rio de uma sequÃªncia.

#### **Exemplos:**

import random

**//Inteiro entre 1 e 10**
numero = random.randint(1, 10)  

**Escolha aleatÃ³ria**
lista = ["cara", "coroa"]  
escolha = random.choice(lista)

**Embaralhar uma lista**
cartas = ["Ãs", "Rei", "Dama"]  
random.shuffle(cartas)

#### **Exemplo com Random:**

import random  

#10 nÃºmeros aleatÃ³rios entre 1 e 100
numeros = [random.randint(1, 100) for _ in range(10)]  

#10 nÃºmeros Ãºnicos entre 1 e 100
numeros_unicos = random.sample(range(1, 101), 10)  

---

### **Resumo dos 20% Essenciais**

1. **Sets:**
   
   - Use para remover duplicatas:Â `set(lista)`.
   
   - Elementos Ãºnicos e nÃ£o ordenados.

2. **Arquivos:**
   
   - Modos:Â `x`Â (criar),Â `a`Â (append),Â `r`Â (ler).
   
   - Sempre feche o arquivo ou useÂ `with open(...) as f`.

3. **Operadores LÃ³gicos:**
   
   - `and`Â exigeÂ **todas**Â condiÃ§Ãµes verdadeiras.
   
   - `or`Â exigeÂ **pelo menos uma**Â condiÃ§Ã£o verdadeira.

4. **Loops (FOR):**
   
   - UseÂ `range()`Â para sequÃªncias numÃ©ricas.
   
   - UseÂ `zip()`Â para combinar listas.

5. **Random:**
   
   - `randint`Â para nÃºmeros aleatÃ³rios.
   
   - `sample`Â para listas Ãºnicas.

---

**Pandas**Â eÂ **Matplotlib**

**Para que servem?**

- **Pandas:**Â Ã‰ a ferramenta para pegar dados "bagunÃ§ados" (planilhas, arquivos de texto, etc.) e transformÃ¡-los em tabelas organizadas e fÃ¡ceis de manipular no Python. Pense no Pandas como um "Excel superpoderoso" dentro do seu cÃ³digo. Essencial paraÂ **limpar, organizar e explorar**Â os dados.

- **Matplotlib:**Â Ã‰ a ferramenta paraÂ **desenhar grÃ¡ficos**Â a partir dos seus dados. Depois que o Pandas organiza a tabela, o Matplotlib ajuda aÂ visualizarÂ as informaÃ§Ãµes, encontrar padrÃµes, tendÃªncias, etc. Uma imagem vale mais que mil linhas de tabela!

**A Estrutura Principal do Pandas: O DataFrame**

- A ideia central do Pandas Ã© oÂ **DataFrame**. Imagine uma planilha (como Excel ou Google Sheets), com linhas e colunas, onde cada coluna tem um nome (um cabeÃ§alho). Ã‰ isso que um DataFrame representa no Python.
  
  Exemplo:Â Quando vocÃª tem dados como:
  
  ```
  cars  passings
  0   BMW         3
  1 Volvo         7
  2  Ford         2
  ```

Isso Ã© um DataFrame. A colunaÂ carsÂ tem os nomes dos carros, a colunaÂ passingsÂ tem nÃºmeros. A coluna da esquerda (0, 1, 2) Ã© oÂ **Ã­ndice**, como o nÃºmero da linha na planilha.

**Como Colocar Dados em um DataFrame? (O mais comum!)**

- Frequentemente, seus dados estarÃ£o em arquivos, comoÂ .csvÂ (valores separados por vÃ­rgula). O Pandas torna super fÃ¡cil ler esses arquivos.

- Exemplo:
  
  ```
  import pandas as pd
  # LÃª o arquivo 'data.csv' e guarda na variÃ¡vel 'df'
  df = pd.read_csv('data.csv')
  # Mostra o conteÃºdo do DataFrame (geralmente as primeiras
  e Ãºltimas linhas)
  print(df)
  ```

Esse comandoÂ pd.read_csv()Â Ã© um dos mais usados. Ele pega o arquivoÂ data.csvÂ (que tem nome, dia de nascimento, etc.) e o transforma naquela estrutura de tabela organizada (DataFrame) dentro da variÃ¡velÂ df.

1. **Como Espiar os Dados no DataFrame?**
   
   - Quando vocÃª tem muitos dados, nÃ£o quer imprimir tudo.
   
   - Exemplo:Â Para ver sÃ³ oÂ **comeÃ§o**Â da tabela:
     
     ```
     print(df.head()) # Mostra as 5 primeiras linhas por padrÃ£o
     print(df.head(10)) # Mostra as 10 primeiras linhas
     ```

Exemplo:Â Para ver sÃ³ oÂ **final**Â da tabela:

```
print(df.tail()) # Mostra as 5 Ãºltimas linhas por padrÃ£o
```

Exemplo:Â Para ter umÂ **resumo**Â da estrutura (tipos de dados, quantas linhas nÃ£o vazias):

```
print(df.info())
```

Isso Ã© Ãºtil para ver rapidamente se hÃ¡ dados faltando (como no exemplo dasÂ CaloriasÂ ondeÂ 164 non-nullÂ indica que faltam 5 valores em 169 linhas).

**Por que Limpar Dados Ã© Crucial?**

- Machine Learning aprende com exemplos. Se os exemplos (dados) estiverem errados, incompletos ou bagunÃ§ados, o aprendizado serÃ¡ ruim ("lixo entra, lixo sai").

- Problemas comuns: cÃ©lulas vazias, formatos errados (texto onde deveria ser nÃºmero), valores impossÃ­veis (idade negativa?), linhas duplicadas.

**Como Lidar com Dados Faltando (O bÃ¡sico)?**

- **OpÃ§Ã£o 1: Remover linhas com dados vazios.**Â Se vocÃª tem muitos dados e poucas linhas com falhas, pode simplesmente removÃª-las.
  
  - Exemplo:
    
    ```
    # Cria NOVO DataFrame sem as linhas que tinham algum valor vazio
    new_df = df.dropna()
    # OU: Remove as linhas do DataFrame ORIGINAL (cuidado!)
    df.dropna(inplace=True)
    ```

**OpÃ§Ã£o 2: Preencher os vazios.**Â Ã€s vezes, remover linhas nÃ£o Ã© bom (perde-se informaÃ§Ã£o). VocÃª pode preencher os buracos com um valor.

- Exemplo:Â PreencherÂ todosÂ os vazios com 130:
  
  ```
  df.fillna(130, inplace=True)
  ```

Exemplo:Â Preencher os vaziosÂ apenas na coluna 'Calorias'Â com 130:

```
df["Calorias"].fillna(130, inplace=True)
```

Exemplo Inteligente:Â Preencher com aÂ **mÃ©dia**,Â **mediana**Â ouÂ **moda**Â da coluna. Ã‰ uma forma mais robusta de nÃ£o distorcer tanto os dados.

**MÃ‰DIA:** `mean` 
**MEDIANA:** `median`
**MODA:** `mode`

```
# Calcula a mÃ©dia da coluna 'Calorias'
media_calorias = df["Calorias"].mean()
# Preenche os vazios na coluna 'Calorias' com a mÃ©dia calculada
df["Calorias"].fillna(media_calorias, inplace=True)
# Poderia usar .median() ou .mode()[0] tambÃ©m
```

(Lembre-se: MÃ©dia Ã© a soma dividida pela quantidade; Mediana Ã© o valor do meio com dados ordenados; Moda Ã© o valor que mais aparece).

**Como Visualizar Dados com Matplotlib (O bÃ¡sico)?**

- Depois de ter o DataFrameÂ dfÂ limpo e organizado pelo Pandas, vocÃª pode usar o Matplotlib para desenhar.

- Exemplo:Â Um grÃ¡fico simples com todas as colunas numÃ©ricas:
  
  ```
  import matplotlib.pyplot as plt
  # Assume que 'df' Ã© seu DataFrame Pandas jÃ¡ carregado e talvez limpo
  df.plot() # Cria um grÃ¡fico (geralmente de linhas)
  plt.show() # Mostra o grÃ¡fico na tela
  ```

OÂ plt.show()Â Ã© essencial para exibir o grÃ¡fico gerado.

Exemplo:Â GrÃ¡fico de Pizza (para mostrar proporÃ§Ãµes):  
Imagine que vocÃª tem uma colunaÂ survivedÂ no arquivoÂ dados4.csvÂ com 0 (nÃ£o sobreviveu) e 1 (sobreviveu). VocÃª quer ver a proporÃ§Ã£o.

```
# (CÃ³digo anterior para contar numA e numB...)
dados = [numA, numB] # Lista com a contagem de 0s e 1s
plt.pie(dados, labels=['NÃ£o Sobreviveu', 'Sobreviveu'])
# Cria o grÃ¡fico de pizza
plt.title('ProporÃ§Ã£o de Sobreviventes') # Adiciona um tÃ­tulo
plt.show() # Mostra o grÃ¡fico
```

Exemplo:Â GrÃ¡fico de DispersÃ£o (para ver relaÃ§Ã£o entre duas variÃ¡veis):  
VocÃª quer ver se existe uma relaÃ§Ã£o entre aÂ DuraÃ§Ã£oÂ do exercÃ­cio e asÂ CaloriasÂ queimadas.

```
# Supondo que 'x' tem os valores da coluna 'Duracao' e 'y' os da coluna 'Calorias'
plt.scatter(df['Duracao'], df['Calorias']) # Cria o grÃ¡fico de dispersÃ£o
plt.title('DuraÃ§Ã£o do ExercÃ­cio vs Calorias Queimadas') # TÃ­tulo
plt.xlabel('DuraÃ§Ã£o (minutos)') # RÃ³tulo do eixo X
plt.ylabel('Calorias') # RÃ³tulo do eixo Y
plt.show() # Mostra o grÃ¡fico
```

**Outros Pontos Importantes (Complemento):**

- **Series:**Â Uma Ãºnica coluna de um DataFrame Ã© chamada deÂ Series. VocÃª pode criar umaÂ SeriesÂ a partir de uma lista ou dicionÃ¡rio, e dar nomes (Ã­ndices) personalizados Ã s linhas (index = ["x", "y", "z"]). Ã‰ o "tijolo" fundamental do DataFrame.

- **Selecionando Dados (loc):**Â OÂ locÂ permite pegar linhas (e colunas) peloÂ rÃ³tuloÂ (Ã­ndice ou nome da coluna).Â print(myvar.loc[0])Â pega a linha com Ã­ndice 0.Â print(myvar.loc[[0, 1]])Â pega as linhas com Ã­ndice 0 e 1.

- **to_string():**Â Se vocÃª quiserÂ realmenteÂ ver todos os dados de um DataFrame grande, useÂ df.to_string(). Sem ele, o Pandas mostra sÃ³ o comeÃ§o e o fim para nÃ£o poluir a tela.

- **pd.options.display.max_rows:**Â Controla quantas linhas o Pandas mostra por padrÃ£o. VocÃª pode aumentar se precisar.

- **Ler JSON:**Â Pandas tambÃ©m lÃª arquivosÂ .jsonÂ (pd.read_json()), que Ã© outro formato comum para guardar dados estruturados.

- **CorreÃ§Ã£o de Formato:**Â pd.to_datetime()Â Ã© Ãºtil para garantir que colunas de data estejam no formato correto.

- **Ajustando Dados Errados:**Â df.loc[linha, coluna] = novo_valorÂ permite corrigir um valor especÃ­fico. VocÃª pode usar isso em um loop (for) para corrigir vÃ¡rios valores (ex: valores deÂ DuracaoÂ acima de 120). OuÂ df.drop(linha)Â para remover uma linha inteira com dado errado.

- **Removendo Duplicatas:**Â df.duplicated()Â mostra quais linhas sÃ£o cÃ³pias exatas de outras.Â df.drop_duplicates(inplace=True)Â remove essas cÃ³pias.

**Resumo da Ã“pera (Foco Pareto):**

UseÂ **Pandas**Â para carregar seus dados (principalmente de arquivos CSV comÂ pd.read_csv) para dentro de umÂ **DataFrame**Â (a tabela). UseÂ head(),Â tail(), eÂ info()Â para dar uma espiada.Â **Limpe os dados**, especialmente tratando valores vazios comÂ dropna()Â ouÂ fillna()Â (usando a mÃ©dia/mediana Ã© uma boa prÃ¡tica). Depois, useÂ **Matplotlib**Â (muitas vezes direto do Pandas comÂ df.plot(), ou com funÃ§Ãµes comoÂ plt.scatter()Â eÂ plt.pie()) paraÂ **visualizar**Â esses dados e entender o que eles dizem. NÃ£o se esqueÃ§a doÂ plt.show()Â para ver seus grÃ¡ficos!

Dominando esses pontos essenciais, vocÃª jÃ¡ tem uma base muito sÃ³lida para comeÃ§ar a trabalhar com dados para Aprendizagem de MÃ¡quina! O resto sÃ£o detalhes e ferramentas mais especÃ­ficas que vocÃª aprenderÃ¡ conforme a necessidade.

---

Agora vamos mergulhar noÂ **Scikit-learn**Â (pronuncia-se "sai-kit learn"), que Ã© como a "caixa de ferramentas principal" do Aprendizado de MÃ¡quina em Python. Se o Pandas Ã© para preparar os dados, o Scikit-learn Ã© para construir e usar os "cÃ©rebros" que aprendem com esses dados.



1. **O que Ã© Scikit-learn?**
   
   - Ã‰ uma biblioteca (um conjunto de cÃ³digos prontos) para Python focadaÂ especificamenteÂ emÂ **Aprendizagem de MÃ¡quina**.
   
   - Ã‰ como ter um kit com vÃ¡rias ferramentas e modelos prontos para vocÃª usar, sem precisar inventar tudo do zero.
   
   - Ã‰Â Open SourceÂ (cÃ³digo aberto e gratuito) e muito popular na comunidade.
   
   - Oferece ferramentas nÃ£o sÃ³ para os modelos em si, mas tambÃ©m para tarefas essenciais como:
     
     - **PrÃ©-processamento:**Â Preparar os dados (vamos ver mais sobre isso).
     
     - **SeleÃ§Ã£o de Modelos:**Â Ajudar a escolher o melhor "cÃ©rebro" para seu problema.
     
     - **AvaliaÃ§Ã£o:**Â Medir quÃ£o bem seu modelo estÃ¡ aprendendo e prevendo.

2. **A Ideia Central:Â fitÂ eÂ predict**
   
   - A maioria dos modelos no Scikit-learn funciona com um fluxo bÃ¡sico de duas etapas:
     
     - **fit(X, y):**Â Ã‰ o processo deÂ **treinamento**Â ouÂ **aprendizado**. VocÃª mostra ao modelo (estimator) os dados de entrada (asÂ **caracterÃ­sticas**, chamadas deÂ X) e as respostas corretas correspondentes (osÂ **resultados**Â ouÂ **rÃ³tulos**, chamados deÂ y). O modelo "estuda" essa relaÃ§Ã£o.
     
     - **predict(X_novo):**Â Depois que o modelo foi treinado (depois doÂ fit), vocÃª usa o mÃ©todoÂ predictÂ para fazerÂ **previsÃµes**Â sobre novos dados (X_novo) para os quais vocÃªÂ nÃ£oÂ sabe a resposta. O modelo usa o que aprendeu para dar um palpite.
   
   - **Analogia:**Â Pense em ensinar uma crianÃ§a a reconhecer frutas (fit). VocÃª mostra vÃ¡rias fotos (X) e diz o nome de cada fruta (y): "Isto Ã© uma maÃ§Ã£", "Isto Ã© uma banana". Depois de aprender, vocÃª mostra uma foto nova que ela nunca viu (X_novo) e pergunta: "O que Ã© isto?". A resposta dela Ã© aÂ predict.
   
   - **Exemplo Conceitual (SalÃ¡rios):**
     
     - XÂ (CaracterÃ­sticas): Uma tabela onde cada linha Ã© um ex-aluno e as colunas sÃ£oÂ ['InstituiÃ§Ã£o', 'Curso', 'Ano de ConclusÃ£o', 'Nota MÃ©dia'].
       
       ```
       X = [
            ['IESB', 'ADS', '2021', '9'],
            ['IESB', 'ADS', '2021', '7'],
            ['outra', 'ADS', '2021', '9'],
            ['IESB', 'ADS', '2023', '9']
           ]
       ```
       
       
     
     - yÂ (Resultados): Uma lista com o salÃ¡rio inicial correspondente a cada ex-aluno emÂ X.
       
       ```
       y = ['3.500', '2.000', '2.500', '4.000']
       ```
       
       
     
     - **Treinamento:**Â modelo.fit(X, y)Â - O modelo aprende a relaÃ§Ã£o entre as caracterÃ­sticas do aluno e seu salÃ¡rio inicial.
     
     - **PrediÃ§Ã£o:**Â VocÃª pergunta: "Qual o salÃ¡rio paraÂ X_novo = ['IESB', 'ADS', '2024', '9']?"

1. - - - salario_previsto = modelo.predict(X_novo)
       
       - O modelo responderia algo comoÂ ['4.200']Â (valor hipotÃ©tico baseado no aprendizado).
         
   
   **A Linguagem da MÃ¡quina: NÃºmeros!**
   
   - Modelos de Machine Learning sÃ£o fundamentalmenteÂ **matemÃ¡ticos/estatÃ­sticos**. Eles nÃ£o entendem "IESB" ou "verde". Eles entendemÂ **nÃºmeros**.
   
   - Portanto, qualquer dado que nÃ£o seja nÃºmero (texto, categorias) precisa serÂ **convertido em nÃºmeros**Â antes de ser usado noÂ fitÂ ouÂ predict.
   
   - Isso vale para imagens (pixels sÃ£o nÃºmeros), sons (amostras sÃ£o nÃºmeros) e, crucialmente, paraÂ **texto**Â eÂ **dados categÃ³ricos**.
   
   
   **Transformando Texto/Categorias em NÃºmeros: A Base**
   
   - **Dados CategÃ³ricos:**Â SÃ£o dados que representam categorias ou qualidades, como "cor" (verde, vermelho, azul), "instituiÃ§Ã£o" (IESB, outra), "forma" (quadrado, triÃ¢ngulo).
   
   - **TokenizaÃ§Ã£o (Ideia Geral):**Â Ã‰ o processo de quebrar texto em pedaÃ§os menores (tokens) e atribuir um nÃºmero a cada pedaÃ§o Ãºnico, criando um "mapa" ou "dicionÃ¡rio" (lÃ©xico/vocabulÃ¡rio).
   
   - **MÃ©todo 1: Label Encoding (CodificaÃ§Ã£o de RÃ³tulo)**
     
     - **Conceito:**Â Simplesmente atribui um nÃºmero inteiro sequencial para cada categoria Ãºnica.
     
     - **Exemplo Tabela:**  
       
       | ID  | Cor      | Forma     |     | ID  | Cor | Forma |
       | --- | -------- | --------- | --- | --- | --- | ----- |
       | 1   | Verde    | Quadrado  | â†’   | 1   | 1   | 1     |
       | 2   | Vermelho | Triangulo | â†’   | 2   | 2   | 2     |
       | 3   | Vermelho | Quadrado  | â†’   | 3   | 2   | 1     |
       | 4   | Azul     | Triangulo | â†’   | 4   | 3   | 2     |
       | 5   | Verde    | Circulo   | â†’   | 5   | 1   | 3     |
       
       (Aqui, Verde=1, Vermelho=2, Azul=3; Quadrado=1, Triangulo=2, Circulo=3)
       
     
     - **Exemplo CÃ³digo (Pandas):**Â Cria uma coluna numÃ©rica representando a categoria.
       
       ```
       import pandas as pd
       
       setCores = ('verde','vermelho','azul')
       dfCores = pd.DataFrame(setCores, columns=['Cores'])
       
       # Converte a coluna para o tipo 'category' do Pandas
       dfCores['Cores'] = dfCores['Cores'].astype('category')
       
       # Cria uma nova coluna ('Cores_cat') com os cÃ³digos numÃ©ricos
       dfCores['Cores_cat'] = dfCores['Cores'].cat.codes
       print(dfCores)
       ```
       
       
       
       SaÃ­da:
       
       ```
       Cores  Cores_cat
       0     verde          1
       1  vermelho          2
       2      azul          0 # Pandas pode comeÃ§ar do 0
       ```
       
       
     
     - **Exemplo CÃ³digo (Scikit-learn):**Â Faz a mesma coisa usandoÂ LabelEncoder.
       
       ```
       import pandas as pd
       from sklearn.preprocessing import LabelEncoder
       
       setCores = ('verde','vermelho','azul','azul','azul',
       'rosa','vermelho')
       dfCores = pd.DataFrame(setCores, columns=['Cores'])
       
       meuLabelEncoder = LabelEncoder() # Cria o codificador
       # Aplica o codificador Ã  coluna 'Cores' e cria 'Cores_cat'
       dfCores['Cores_cat'] = meuLabelEncoder.fit_transform(dfCores
       ['Cores'])
       print(dfCores)
       ```





1. - - SaÃ­da:
       
       ```
       Cores  Cores_cat
       0     verde          2 #NÃºm. dependem ordem alfabÃ©tica/apariÃ§Ã£o
       1  vermelho          3
       2      azul          0
       3      azul          0
       4      azul          0
       5      rosa          1
       6  vermelho          3
       ```
       
       
     
     - **PROBLEMA do Label Encoding:**Â O modelo pode interpretar umaÂ **ordem ou magnitude**Â que nÃ£o existe. Ele pode achar que "Vermelho" (3) Ã© "maior" ou "mais importante" que "Azul" (0), o que geralmente nÃ£o faz sentido para categorias nominais.
       
   
   - **MÃ©todo 2: One-Hot Encoding (CodificaÃ§Ã£o "Quente Ãšnica")**
     
     - **Conceito:**Â Resolve o problema do Label Encoding. Em vez de uma Ãºnica coluna com nÃºmeros diferentes, ele criaÂ **novas colunas**, uma paraÂ cadaÂ categoria possÃ­vel. O valor serÃ¡Â 1Â na coluna correspondente Ã  categoria daquela linha eÂ 0Â nas outras.
     
     - **Exemplo Tabela:**  
       
       | ID  | Cor      | Forma     |     | ID  | ... | Azul | Verde | Verm. | CÃ­rc. | Quad. | Triang. |
       | --- | -------- | --------- | --- | --- | --- | ---- | ----- | ----- | ----- | ----- | ------- |
       | 1   | Verde    | Quadrado  | â†’   | 1   | ... | 0    | 1     | 0     | 0     | 1     | 0       |
       | 2   | Vermelho | Triangulo | â†’   | 2   | ... | 0    | 0     | 1     | 0     | 0     | 1       |
       | 3   | Vermelho | Quadrado  | â†’   | 3   | ... | 0    | 0     | 1     | 0     | 1     | 0       |
       | 4   | Azul     | Triangulo | â†’   | 4   | ... | 1    | 0     | 0     | 0     | 0     | 1       |
       | 5   | Verde    | Circulo   | â†’   | 5   | ... | 0    | 1     | 0     | 1     | 0     | 0       |
     
     - **Exemplo CÃ³digo (Scikit-learn):**Â Geralmente feito apÃ³s o Label Encoding ou direto na coluna categÃ³rica.
       
       ```
       import pandas as pd
       from sklearn.preprocessing import LabelEncoder, OneHotEncoder
       
       setCores = ('verde','vermelho','azul','azul','azul',
       'rosa','vermelho')
       dfCores = pd.DataFrame(setCores, columns=['Cores'])
       
       # Passo 1: Label Encoding (como antes)
       meuLabelEncoder = LabelEncoder()
       dfCores['Cores_cat'] = meuLabelEncoder.fit_transform(dfCores
       ['Cores'])
       
       # Passo 2: One-Hot Encoding
       enc = OneHotEncoder(handle_unknown='ignore', sparse_output=
       False) # Cria o OneHotEncoder
       # Aplica na coluna _numÃ©rica_ 'Cores_cat' e cria um DataFrame
       com as novas colunas
       # O .toarray() Ã© importante se sparse=True (padrÃ£o antigo),
       ou use sparse_output=False
       dfEnc = pd.DataFrame(enc.fit_transform(dfCores[['Cores_cat']]))
       
       # Junta as novas colunas (0, 1, 2, 3) ao DataFrame original
       dfCores = dfCores.join(dfEnc)
       print(dfCores)
       ```
       
       
       
       SaÃ­da:
       
       ```
       Cores  Cores_cat    0    1    2    3
       0     verde          2  0.0  0.0  1.0  0.0  #Col2 (verde) Ã© 1
       1  vermelho          3  0.0  0.0  0.0  1.0  #Col3(vermelho) Ã© 1
       2      azul          0  1.0  0.0  0.0  0.0  #Col0 (azul) Ã© 1
       3      azul          0  1.0  0.0  0.0  0.0
       4      azul          0  1.0  0.0  0.0  0.0
       5      rosa          1  0.0  1.0  0.0  0.0  #Col1(rosa) Ã© 1
       6  vermelho          3  0.0  0.0  0.0  1.0
       ```
       
       
     
     - **Passo Final Importante:**Â Depois de criar as colunas One-Hot,Â **remova**Â a coluna original de texto (Cores) e a coluna intermediÃ¡ria do Label Encoding (Cores_cat), pois elas sÃ£o redundantes e aÂ Cores_catÂ ainda tem o problema da ordem implÃ­cita.
       
       ```
       # Remove a coluna 'Cores_cat' (Ã­ndice 1 se for a segunda
       coluna)
       dfCores.drop(['Cores_cat'], axis=1, inplace=True)
       # Poderia remover a 'Cores' tambÃ©m: dfCores.drop(['Cores'], 
       axis=1, inplace=True)
       # Ou remover por posiÃ§Ã£o (cuidado se a ordem mudar):
       # dfCores.drop(dfCores.iloc[:, 1:2], axis=1, inplace=True) 
       # Remove a segunda coluna
       print(dfCores)
       ```
       
       
       
       SaÃ­da Final (pronta para o modelo):
       
       ```
       Cores    0    1    2    3
       0     verde  0.0  0.0  1.0  0.0
       1  vermelho  0.0  0.0  0.0  1.0
       2      azul  1.0  0.0  0.0  0.0
       3      azul  1.0  0.0  0.0  0.0
       4      azul  1.0  0.0  0.0  0.0
       5      rosa  0.0  1.0  0.0  0.0
       6  vermelho  0.0  0.0  0.0  1.0
       # (Geralmente a coluna 'Cores' original tambÃ©m seria removida)
       ```
       
       

**Outros Pontos Mencionados (Complemento):**

- **Estimators:**Â Ã‰ o nome genÃ©rico que o Scikit-learn dÃ¡ aos seusÂ **modelos**Â (os "cÃ©rebros"). Eles podem ser:
  
  - Supervisionados:Â Aprendem comÂ XÂ eÂ yÂ (como o exemplo do salÃ¡rio e oÂ RandomForestClassifier).
  
  - NÃ£o Supervisionados:Â Aprendem padrÃµes apenas comÂ XÂ (sem respostasÂ y).
  
  - Transformadores:Â NÃ£o sÃ£o modelos de previsÃ£o, mas ferramentas para modificar os dados (comoÂ LabelEncoderÂ eÂ OneHotEncoder).

- **Tipos de Dados Aceitos:**Â Scikit-learn trabalha bem comÂ Arrays do NumpyÂ (a base numÃ©rica do Python cientÃ­fico) eÂ DataFrames do PandasÂ (depois que vocÃª converteu tudo para nÃºmero!).

- **ExemploÂ RandomForestClassifier:**
  
  ```
  from sklearn.ensemble import RandomForestClassifier
  clf = RandomForestClassifier(random_state=0) # Cria o modelo
  X = [[ 1, 2, 3], [11, 12, 13]] # Duas amostras com 3 caracterÃ­sticas
  cada
  y = [0, 1] # Resultado 0 para a primeira amostra, 1 para a segunda
  clf.fit(X, y) # Treina o modelo: aprende que [1,2,3] -> 0 e
  [11,12,13] -> 1
  # Pede previsÃµes para novas amostras:
  print(clf.predict([[4, 5, 6], [14, 15, 16]]))
  # SaÃ­da: [0 1] -> O modelo generalizou que nÃºmeros baixos
  (~1,2,3) levam a 0
  # e nÃºmeros altos (~11,12,13) levam a 1.
  ```
  
  
  
  Este Ã© um exemploÂ muitoÂ simples, mas ilustra o fluxoÂ fitÂ ->Â predict.

- **Outras Formas de TokenizaÃ§Ã£o (para texto livre):**
  
  - **Por Letras:**Â Token = cada letra. VocabulÃ¡rio pequeno (sÃ³ alfabeto + sÃ­mbolos), mas a sequÃªncia numÃ©rica fica muito longa e complexa para o modelo entender relaÃ§Ãµes.
    
    - O IESB ...Â ->Â [15, 0, 9, 5, 19, ...]Â (onde 15=O, 0=espaÃ§o, 9=I, etc.)
  
  - **Por Palavras:**Â Token = cada palavra. Faz mais sentido semanticamente, mas o vocabulÃ¡rio fica enorme (ex: 320 mil palavras em portuguÃªs) e lida mal com palavras novas ou erros de digitaÃ§Ã£o.
    
    - O IESB tem ...Â ->Â [1, 290, 8900, ...]Â (onde 1=O, 290=IESB, etc. - nÃºmeros ilustrativos)
  
  - **Por Subpalavras (Radical, Prefixo, Sufixo - N-gramas):**Â Um meio-termo eficiente. Quebra palavras em partes menores (beb-,Â -er,Â -endo). Reduz o vocabulÃ¡rio comparado a palavras inteiras e lida melhor com variaÃ§Ãµes (beber,Â bebendo) e palavras novas.
    
    

- **Embedding:**
  
  - Uma tÃ©cnica mais avanÃ§ada que TokenizaÃ§Ã£o/One-Hot Encoding, especialmente para texto.
  
  - Representa palavras ou tokens nÃ£o como um Ãºnico nÃºmero (ID) ou um vetor esparso (One-Hot), mas como umÂ **vetor denso**Â de nÃºmeros (ex:Â [0.12, -0.45, 0.88, ...], com dezenas ou centenas de dimensÃµes).
  
  - AÂ **posiÃ§Ã£o**Â desse vetor em um espaÃ§o multi-dimensional captura oÂ **significado semÃ¢ntico**Â e oÂ **contexto**Â da palavra. Palavras similares (ex: "rei", "rainha") terÃ£o vetores prÃ³ximos nesse espaÃ§o.
  
  - O mesmo token (ex: a palavra "banco") pode terÂ embeddings diferentesÂ dependendo do contexto ("sentar no banco" vs "ir ao banco").
    

**Resumo da Ã“pera (Foco Pareto):**

**Scikit-learn**Â Ã© sua caixa de ferramentas para construir modelos de Machine Learning. O fluxo principal Ã©Â **fit(X, y)Â para treinar**Â (mostrar exemplosÂ XÂ e respostasÂ y) eÂ **predict(X_novo)Â para usar**Â (prever respostas para novos dados). Lembre-se: modelos entendemÂ **nÃºmeros**. Dados categÃ³ricos (texto) precisam ser convertidos.Â **Label Encoding**Â Ã© simples (um nÃºmero por categoria) mas pode confundir o modelo.Â **One-Hot Encoding**Â Ã© mais seguro (cria colunas 0/1 para cada categoria) e Ã© o mÃ©todo preferido para dados categÃ³ricos nominais. DominarÂ fit,Â predictÂ e como preparar dados numÃ©ricos (incluindo One-Hot Encoding para categorias) Ã© oÂ essencialÂ para comeÃ§ar com Scikit-learn.
